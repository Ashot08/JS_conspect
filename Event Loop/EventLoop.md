# Event Loop

## Движок JavaScript (JS engine, ранее - JS interpreter)
Например, V8 (Google Chrome, Chromium, NodeJS), Spider_Monkey (Firefox)

__Движок предоставляет:__
- кучу (heap) - область памяти для хранения объектов, массивов, переменных, функций итп,
- выделение памяти и сборка мусора,
- стек вызовов (call stack),
- компиляцию JS в машинный код

Event Loop __не является частью движка__

Event Loop - это отдельный механизм для реализации неблокирующей модели ввода/вывода. 

## Стек вызовов (call stack)

Стек вызовов хранит в себе перечень ещё не вызванных функций, в том порядке, в каком они будут вызваны (синхронно - шаг за шагом). 
Если стек не пустой, то функции из него вызываются поочередно по принципу LIFO (last in first out).
```
function first () {
    second();
    console.log('1');
}

function second() {
    third();
    console.log('2');
}

function third() {
    console.log('3');
}

first();
```
В стеке вызовов эти функции разместятся в следующем порядке:
```
third()
second()
first()
```
При запуске кода
```
    // в консоли мы увидим:
    3
    2
    1
```
Таким образом, функции из стека вызовов выполняются синхронно, одна за одной. 
Если какая-то из функций будет выполняться очень долго, то интерфейс браузера будет полностью заблокирован
до тех пор, пока функция не завершит выполнение.
### Переполнение

При вызове очень большого числа функций стек вызовов может быть переполнен. В этом случае мы получим ошибку.

## Асинхронность

Механизм асинхронности предназначен для того, чтобы не блокировать выполнение кода функциями, 
которые выполняются долго или, например, отправляют запрос и ждут ответ из сети. 

Для этого существует __очередь задач__ и Web API

### Пример

```
console.log('1');
setTimeout(()=>console.log('2'), 3000)
console.log('3');
```
Если бы этот код выполнялся синхронно, то после вывода в консоль ```1``` 
нам бы пришлось ждать 3 секунды до вывода ```2```, и только потом вывелась бы ```3```. 
При этом в течение всех трех секунд интерфейс браузера был бы заблокирован.

Но в реальности, благодаря асинхронности функции ```setTimeout```, интерфейс не будет заблокирован 
и после выполнения кода мы увидим в консоли:
```
1
3
```
и через 3 секунды
```
2
```
Как это работает?

Сперва функции попадут в стек вызовов и начнут выполняться:
```
console.log('1');
setTimeout(...)
console.log('3');
```
при выполнении ```setTimeout``` переданный в него коллбэк выполнится не сразу, а будет перенесен в __очередь задач__.
Затем выполнится ```console.log('3')```. 

После этого (когда стек вызовов будет пуст) всё что в __очереди задач__ (т.е. в нашем случае ```console.log('2')```) 
будет помещено в стек вызовов и будет выполнено.

Итак, движок предоставляет стек вызовов, а EventLoop предоставляет очередь задач (которая делится на микро и макро задачи - об этом речь пойдет дальше), 
а взаимодействуют они друг с другом с помощью __Web API__.

### Web API

Web API - это интерфейс в который входят события ('onclick', 'onsubmit', ), таймеры (setTimeout), функции отправки запросов (fetch).

С помощью Web API коллбэки асинхронных функций из стека вызовов передаются в __очередь задач__.
